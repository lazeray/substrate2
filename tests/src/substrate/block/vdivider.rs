use std::{collections::HashMap, sync::Arc};

use arcstr::ArcStr;
use serde::{Deserialize, Serialize};

use substrate::{
    block::Block,
    schematic::{
        cell::SchematicCell,
        context::SchematicCtx,
        instance::{Instance, SchematicInstance},
        interface::{AnalogInterface, Port, SignalMap},
        HasSchematic,
    },
};

use super::resistor::Resistor;

#[derive(Debug, Clone, Copy)]
pub struct VDividerIntf {
    pub vdd: Port,
    pub vss: Port,
    pub vout: Port,
}

// AUTOGENERATED CODE BEGIN
impl AnalogInterface<VDivider> for VDividerIntf {
    fn register(&mut self, map: &mut SignalMap) {
        self.vdd = map.register_port();
        self.vss = map.register_port();
        self.vout = map.register_port();
    }
}
// AUTOGENERATED CODE END

#[derive(Serialize, Deserialize)]
pub struct VDivider {
    pub r1: usize,
    pub r2: usize,
}

impl Block for VDivider {
    fn id() -> ArcStr {
        arcstr::literal!("vdivider")
    }

    fn name(&self) -> ArcStr {
        arcstr::format!("vdivider_{}_{}", self.r1, self.r2)
    }
}

// AUTOGENERATED CODE BEGIN
pub struct VDividerCell {
    intf: VDividerIntf,
    instances: Vec<Instance>,
}

impl SchematicCell<VDivider> for VDividerCell {
    fn new(intf: VDividerIntf) -> Self {
        VDividerCell {
            intf,
            instances: Vec::new(),
        }
    }

    fn add_instance(&mut self, inst: impl Into<Instance>) {
        self.instances.push(inst.into());
    }

    fn instances(&self) -> &Vec<Instance> {
        &self.instances
    }
}

pub struct VDividerInstance {
    name: ArcStr,
    intf: VDividerIntf,
    cell: Arc<VDividerCell>,
}

impl Into<Instance> for VDividerInstance {
    fn into(self) -> Instance {
        Instance {
            name: self.name,
            instances: self.cell.instances().clone(),
            ports: HashMap::from_iter([
                ("vdd".into(), self.intf.vdd),
                ("vss".into(), self.intf.vss),
                ("vout".into(), self.intf.vout),
            ]),
        }
    }
}

impl SchematicInstance<VDivider> for VDividerInstance {
    fn new(name: impl Into<ArcStr>, intf: VDividerIntf, cell: Arc<VDividerCell>) -> Self {
        VDividerInstance {
            name: name.into(),
            intf,
            cell,
        }
    }

    fn name(&self) -> ArcStr {
        self.name.clone()
    }

    fn intf(&self) -> &VDividerIntf {
        &self.intf
    }
}
// AUTOGENERATED CODE END

impl HasSchematic for VDivider {
    type Interface = VDividerIntf;
    type Cell = VDividerCell;
    type Instance = VDividerInstance;

    fn schematic(&self, ctx: &mut SchematicCtx) -> Self::Cell {
        let mut cell = Self::Cell::new(VDividerIntf::new());

        let res1 = ctx.generate("Xr1", Resistor { r: self.r1 });
        let res2 = ctx.generate("Xr2", Resistor { r: self.r2 });

        cell.add_instance(res1.clone());
        cell.add_instance(res2.clone());

        cell.connect(res1.intf().p, intf.vdd);
        cell.connect(res1.intf().n, res2.intf().p);
        cell.connect(res2.intf().n, intf.vss);

        cell
    }
}
