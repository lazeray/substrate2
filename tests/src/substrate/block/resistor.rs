use std::{collections::HashMap, sync::Arc};

use arcstr::ArcStr;
use serde::{Deserialize, Serialize};

use substrate::{
    block::Block,
    schematic::{
        cell::SchematicCell,
        context::SchematicCtx,
        instance::{Instance, SchematicInstance},
        interface::{AnalogInterface, Port, SignalMap},
        HasSchematic,
    },
};

#[derive(Debug, Clone, Copy)]
pub struct ResistorIntf {
    pub p: Port,
    pub n: Port,
}

// AUTOGENERATED CODE BEGIN
impl AnalogInterface<Resistor> for ResistorIntf {
    fn register(ctx: &mut SchematicCtx) -> Self {
        ResistorIntf {
            p: ctx.register_port(),
            n: ctx.register_port(),
        }
    }
}
// AUTOGENERATED CODE END

#[derive(Serialize, Deserialize)]
pub struct Resistor {
    pub r: usize,
}

impl Block for Resistor {
    fn id() -> ArcStr {
        arcstr::literal!("resistor")
    }

    fn name(&self) -> ArcStr {
        arcstr::format!("resistor_{}", self.r)
    }
}

// AUTOGENERATED CODE BEGIN
#[derive(Debug, Clone)]
pub struct ResistorCell {
    intf: ResistorIntf,
    instances: Vec<Instance>,
    signal_map: SignalMap,
}

impl SchematicCell<Resistor> for ResistorCell {
    fn new(intf: ResistorIntf) -> Self {
        ResistorCell {
            intf,
            instances: Vec::new(),
            signal_map: SignalMap::new(),
        }
    }

    fn add_instance(&mut self, inst: impl Into<Instance>) {
        self.instances.push(inst.into());
    }

    fn instances(&self) -> &Vec<Instance> {
        &self.instances
    }

    fn signal_map(&self) -> &SignalMap {
        &self.signal_map
    }

    fn signal_map_mut(&mut self) -> &mut SignalMap {
        &mut self.signal_map
    }
}

#[derive(Debug, Clone)]
pub struct ResistorInstance {
    name: ArcStr,
    intf: ResistorIntf,
    cell: Arc<ResistorCell>,
}

#[allow(clippy::from_over_into)]
impl Into<Instance> for ResistorInstance {
    fn into(self) -> Instance {
        Instance {
            name: self.name,
            instances: self.cell.instances().clone(),
            ports: HashMap::from_iter([
                ("p".into(), self.cell.intf.p),
                ("n".into(), self.cell.intf.n),
            ]),
        }
    }
}

impl SchematicInstance<Resistor> for ResistorInstance {
    fn new(name: impl Into<ArcStr>, intf: ResistorIntf, cell: Arc<ResistorCell>) -> Self {
        ResistorInstance {
            name: name.into(),
            intf,
            cell,
        }
    }

    fn name(&self) -> ArcStr {
        self.name.clone()
    }

    fn intf(&self) -> &ResistorIntf {
        &self.intf
    }
}
// AUTOGENERATED CODE END

impl HasSchematic for Resistor {
    type Interface = ResistorIntf;
    type Cell = ResistorCell;
    type Instance = ResistorInstance;

    fn schematic(&self, ctx: &mut SchematicCtx) -> Self::Cell {
        let intf = ctx.instantiate::<Self::Interface>();

        Self::Cell::new(intf)
    }
}
