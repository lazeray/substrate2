use std::collections::HashMap;

use arcstr::ArcStr;
use serde::{Deserialize, Serialize};

use crate::{
    block::Block,
    schematic::{
        cell::SchematicCell,
        context::SchematicCtx,
        interface::{AnalogInterface, Port, SignalMap},
        HasSchematic,
    },
};

#[derive(Debug, Clone, Copy)]
pub struct ResistorIntf {
    pub p: Port,
    pub n: Port,
}

// AUTOGENERATED CODE BEGIN
#[derive(Debug, Clone, Copy)]
pub struct ResistorIntfUninitialized;

#[allow(clippy::new_ret_no_self)]
impl ResistorIntf {
    fn new() -> ResistorIntfUninitialized {
        ResistorIntfUninitialized
    }
}

impl AnalogInterface<Resistor> for ResistorIntf {
    type Uninitialized = ResistorIntfUninitialized;

    fn initialize(_intf: Self::Uninitialized, map: &mut SignalMap) -> Self {
        ResistorIntf {
            p: map.register_port(),
            n: map.register_port(),
        }
    }

    fn uninitialized(self) -> ResistorIntfUninitialized {
        ResistorIntfUninitialized
    }

    fn ports(&self) -> HashMap<ArcStr, Port> {
        HashMap::from_iter([("p".into(), self.p), ("n".into(), self.n)])
    }
}
// AUTOGENERATED CODE END

#[derive(Serialize, Deserialize)]
pub struct Resistor {
    pub r: usize,
}

impl Block for Resistor {
    fn id() -> ArcStr {
        arcstr::literal!("resistor")
    }

    fn name(&self) -> ArcStr {
        arcstr::format!("resistor_{}", self.r)
    }
}

impl HasSchematic for Resistor {
    type Interface = ResistorIntf;

    fn schematic(&self, _ctx: &mut SchematicCtx) -> SchematicCell<Resistor> {
        SchematicCell::<Resistor>::new(ResistorIntf::new())
    }
}
